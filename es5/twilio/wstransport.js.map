{"version":3,"file":"wstransport.js","sourceRoot":"","sources":["../../lib/twilio/wstransport.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;;;;;;;;;;;;;AAEH,iCAAsC;AACtC,8BAAgC;AAChC,mCAA2C;AAC3C,6BAAwB;AAExB,2BAA2B;AAC3B,IAAM,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AAEnC,IAAM,uBAAuB,GAAG,KAAK,CAAC;AACtC,IAAM,eAAe,GAAG,IAAI,CAAC;AAC7B,IAAM,iBAAiB,GAAG,KAAK,CAAC;AAQhC;;GAEG;AACH,IAAY,gBAeX;AAfD,WAAY,gBAAgB;IAC1B;;OAEG;IACH,6CAAyB,CAAA;IAEzB;;OAEG;IACH,qCAAiB,CAAA;IAEjB;;OAEG;IACH,iCAAa,CAAA;AACf,CAAC,EAfW,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAe3B;AAuBD;;GAEG;AACH;IAAyC,+BAAY;IA2EnD;;;;OAIG;IACH,qBAAY,IAAc,EAAE,OAA6C;QAA7C,wBAAA,EAAA,YAA6C;QAAzE,YACE,iBAAO,SAsCR;QAtHD;;WAEG;QACH,WAAK,GAAqB,gBAAgB,CAAC,MAAM,CAAC;QA8BlD;;WAEG;QACK,UAAI,GAAQ,aAAG,CAAC,WAAW,EAAE,CAAC;QAOtC;;;WAGG;QACK,qBAAe,GAAY,KAAK,CAAC;QAYzC;;WAEG;QACK,eAAS,GAAW,CAAC,CAAC;QA+L9B;;;WAGG;QACK,mBAAa,GAAG;YACtB,KAAI,CAAC,SAAS,EAAE,CAAC;YACjB,IAAI,KAAI,CAAC,SAAS,IAAI,KAAI,CAAC,KAAK,CAAC,MAAM,EAAE;gBACvC,KAAI,CAAC,SAAS,GAAG,CAAC,CAAC;aACpB;QACH,CAAC,CAAA;QAED;;WAEG;QACK,oBAAc,GAAG,UAAC,KAAiB;YACzC,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,0CAAwC,KAAK,CAAC,IAAI,kBAAa,KAAK,CAAC,MAAQ,CAAC,CAAC;YAC9F,wDAAwD;YACxD,4BAA4B;YAC5B,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,EAAE;gBAC9C,KAAI,CAAC,IAAI,CAAC,OAAO,EAAE;oBACjB,IAAI,EAAE,KAAK;oBACX,OAAO,EAAE,KAAK,CAAC,MAAM;wBACnB,2DAA2D;4BAC3D,mEAAmE;4BACnE,iEAAiE;4BACjE,8DAA8D;oBAChE,WAAW,EAAE,IAAI,wBAAe,CAAC,eAAe,EAAE;iBACnD,CAAC,CAAC;gBAEH,IAAM,YAAY,GAAG;gBACnB,6GAA6G;gBAC7G,yEAAyE;gBACzE,2DAA2D;gBAC3D,KAAI,CAAC,KAAK,KAAK,gBAAgB,CAAC,IAAI;oBAEpC,gDAAgD;oBAChD,4EAA4E;oBAC5E,yDAAyD;oBACzD,KAAI,CAAC,cAAc,KAAK,gBAAgB,CAAC,IAAI,CAC9C,CAAC;gBAEF,+CAA+C;gBAC/C,0CAA0C;gBAC1C,IAAI,KAAI,CAAC,eAAe,IAAI,CAAC,YAAY,EAAE;oBACzC,KAAI,CAAC,aAAa,EAAE,CAAC;iBACtB;gBAED,KAAI,CAAC,eAAe,GAAG,IAAI,CAAC;aAC7B;YACD,KAAI,CAAC,YAAY,EAAE,CAAC;QACtB,CAAC,CAAA;QAED;;WAEG;QACK,oBAAc,GAAG,UAAC,GAAU;YAClC,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,+BAA6B,GAAG,CAAC,OAAS,CAAC,CAAC;YAC3D,KAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBACjB,IAAI,EAAE,KAAK;gBACX,OAAO,EAAE,GAAG,CAAC,OAAO,IAAI,0BAA0B;gBAClD,WAAW,EAAE,IAAI,wBAAe,CAAC,sBAAsB,EAAE;aAC1D,CAAC,CAAC;QACL,CAAC,CAAA;QAED;;WAEG;QACK,sBAAgB,GAAG,UAAC,OAAsB;YAChD,2DAA2D;YAC3D,qCAAqC;YACrC,KAAI,CAAC,oBAAoB,EAAE,CAAC;YAE5B,mCAAmC;YACnC,IAAI,KAAI,CAAC,OAAO,IAAI,OAAO,CAAC,IAAI,KAAK,IAAI,EAAE;gBACzC,KAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACxB,OAAO;aACR;YAED,KAAI,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAChC,CAAC,CAAA;QAED;;WAEG;QACK,mBAAa,GAAG;YACtB,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,gCAAgC,CAAC,CAAC;YACjD,KAAI,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAC9B,KAAI,CAAC,eAAe,GAAG,KAAK,CAAC;YAC7B,KAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;YACtC,YAAY,CAAC,KAAI,CAAC,eAAe,CAAC,CAAC;YAEnC,KAAI,CAAC,oBAAoB,EAAE,CAAC;YAC5B,KAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACpB,CAAC,CAAA;QAxQC,KAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,gBAAgB,IAAI,eAAe,CAAC;QAErE,IAAI,YAAY,GAAG,GAAG,CAAC;QACvB,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;YAC3B,sEAAsE;YACtE,iDAAiD;YACjD,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACrE;QAED,IAAM,aAAa,GAAG;YACpB,MAAM,EAAE,GAAG;YACX,YAAY,cAAA;YACZ,QAAQ,EAAE,OAAO,OAAO,CAAC,YAAY,KAAK,QAAQ;gBAChD,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;gBACtC,CAAC,CAAC,KAAK;YACT,mBAAmB,EAAE,IAAI;SAC1B,CAAC;QAEF,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,+CAA+C,EAAE,aAAa,CAAC,CAAC;QAC/E,KAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;QAEnD,KAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,KAAI,CAAC,UAAU,GAAG,OAAO,CAAC,SAAS,IAAI,SAAS,CAAC;QAEjD,0CAA0C;QAC1C,KAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,SAAS,EAAE,UAAC,CAAM,EAAE,KAAa;YAChD,IAAI,KAAI,CAAC,KAAK,KAAK,gBAAgB,CAAC,MAAM,EAAE;gBAAE,OAAO;aAAE;YACvD,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,4CAA0C,KAAK,OAAI,CAAC,CAAC;QACtE,CAAC,CAAC,CAAC;QAEH,gEAAgE;QAChE,+BAA+B;QAC/B,KAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,OAAO,EAAE,UAAC,OAAe;YACxC,IAAI,KAAI,CAAC,KAAK,KAAK,gBAAgB,CAAC,MAAM,EAAE;gBAAE,OAAO;aAAE;YACvD,KAAI,CAAC,QAAQ,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;QAC7B,CAAC,CAAC,CAAC;;IACL,CAAC;IAED;;OAEG;IACH,2BAAK,GAAL;QACE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,+BAA+B,CAAC,CAAC;QAChD,IAAI,CAAC,MAAM,EAAE,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,0BAAI,GAAJ;QACE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,8BAA8B,CAAC,CAAC;QAE/C,IAAI,IAAI,CAAC,OAAO;YACZ,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,KAAK,SAAS,CAAC,UAAU;gBACjD,IAAI,CAAC,OAAO,CAAC,UAAU,KAAK,SAAS,CAAC,IAAI,CAAC,EAAE;YAC/C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAC;YAC1C,OAAO;SACR;QAED,IAAI,CAAC,QAAQ,EAAE,CAAC;IAClB,CAAC;IAED;;;;OAIG;IACH,0BAAI,GAAJ,UAAK,OAAe;QAClB,wDAAwD;QACxD,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,UAAU,KAAK,SAAS,CAAC,IAAI,EAAE;YAC/D,OAAO,KAAK,CAAC;SACd;QAED,IAAI;YACF,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC5B;QAAC,OAAO,CAAC,EAAE;YACV,wEAAwE;YACxE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,8BAA8B,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;YAC1D,IAAI,CAAC,YAAY,EAAE,CAAC;YACpB,OAAO,KAAK,CAAC;SACd;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACK,4BAAM,GAAd;QACE,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QACxC,IAAI,CAAC,YAAY,EAAE,CAAC;IACtB,CAAC;IAED;;OAEG;IACK,kCAAY,GAApB;QACE,YAAY,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QACnC,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAErC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,sCAAsC,CAAC,CAAC;QAEvD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,2BAA2B,CAAC,CAAC;YAC5C,OAAO;SACR;QAED,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,cAAqB,CAAC,CAAC;QACtE,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,cAAqB,CAAC,CAAC;QACtE,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,gBAAuB,CAAC,CAAC;QAC1E,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,aAAoB,CAAC,CAAC;QAEpE,IAAI,IAAI,CAAC,OAAO,CAAC,UAAU,KAAK,SAAS,CAAC,UAAU;YAChD,IAAI,CAAC,OAAO,CAAC,UAAU,KAAK,SAAS,CAAC,IAAI,EAAE;YAC9C,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;SACtB;QAED,2FAA2F;QAC3F,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,WAAW,GAAG,uBAAuB,EAAE;YAC/E,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;SACvB;QAED,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;QACxB,OAAO,IAAI,CAAC,OAAO,CAAC;QAEpB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACrB,CAAC;IAED;;;;OAIG;IACK,8BAAQ,GAAhB,UAAiB,UAAmB;QAApC,iBAoCC;QAnCC,IAAI,UAAU,EAAE;YACd,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,qCAAmC,UAAU,SAAM,CAAC,CAAC;SACrE;aAAM;YACL,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC;SAC5C;QAED,IAAI,CAAC,YAAY,EAAE,CAAC;QAEpB,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;QAC5C,IAAI,MAAM,GAAG,IAAI,CAAC;QAClB,IAAI;YACF,MAAM,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;SAC1D;QAAC,OAAO,CAAC,EAAE;YACV,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,gCAAgC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;YAC5D,IAAI,CAAC,MAAM,EAAE,CAAC;YACd,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBACjB,IAAI,EAAE,KAAK;gBACX,OAAO,EAAE,CAAC,CAAC,OAAO,IAAI,0BAAwB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAG;gBAC1E,WAAW,EAAE,IAAI,wBAAe,CAAC,sBAAsB,EAAE;aAC1D,CAAC,CAAC;YACH,OAAO;SACR;QAED,OAAO,IAAI,CAAC,WAAW,CAAC;QACxB,IAAI,CAAC,eAAe,GAAG,UAAU,CAAC;YAChC,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,yCAAyC,CAAC,CAAC;YAC1D,KAAI,CAAC,aAAa,EAAE,CAAC;YACrB,KAAI,CAAC,YAAY,EAAE,CAAC;QACtB,CAAC,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAE3B,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAAC,cAAqB,CAAC,CAAC;QAC7D,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAAC,cAAqB,CAAC,CAAC;QAC7D,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC,gBAAuB,CAAC,CAAC;QACjE,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAAC,aAAoB,CAAC,CAAC;QAC3D,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAiGD;;;OAGG;IACK,0CAAoB,GAA5B;QAAA,iBAOC;QANC,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QACrC,IAAI,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClC,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,6BAA2B,iBAAiB,GAAG,IAAI,8BAA2B,CAAC,CAAC;YAC/F,KAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAC5B,KAAI,CAAC,YAAY,EAAE,CAAC;QACtB,CAAC,EAAE,iBAAiB,CAAC,CAAC;IACxB,CAAC;IAED;;OAEG;IACK,+BAAS,GAAjB,UAAkB,KAAuB;QACvC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC;QACjC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IAKD,sBAAI,4BAAG;QAHP;;WAEG;aACH;YACE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACpC,CAAC;;;OAAA;IACH,kBAAC;AAAD,CAAC,AAxXD,CAAyC,qBAAY,GAwXpD","sourcesContent":["/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport * as WebSocket from 'ws';\nimport { SignalingErrors } from './errors';\nimport Log from './log';\n\n// tslint:disable-next-line\nconst Backoff = require('backoff');\n\nconst CONNECT_SUCCESS_TIMEOUT = 10000;\nconst CONNECT_TIMEOUT = 5000;\nconst HEARTBEAT_TIMEOUT = 15000;\n\nexport interface IMessageEvent {\n  data: string;\n  target: WebSocket;\n  type: string;\n}\n\n/**\n * All possible states of WSTransport.\n */\nexport enum WSTransportState {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  Closed = 'closed',\n\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  Open = 'open',\n}\n\n/**\n * Options to be passed to the WSTransport constructor.\n */\nexport interface IWSTransportConstructorOptions {\n  /**\n   * Maximum time to wait before attempting to reconnect the signaling websocket.\n   * Default is 20000ms. Minimum is 3000ms.\n   */\n  backoffMaxMs?: number;\n\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  connectTimeoutMs?: number;\n\n  /**\n   * A WebSocket factory to use instead of WebSocket.\n   */\n  WebSocket?: any;\n}\n\n/**\n * WebSocket Transport\n */\nexport default class WSTransport extends EventEmitter {\n  /**\n   * The current state of the WSTransport.\n   */\n  state: WSTransportState = WSTransportState.Closed;\n\n  /**\n   * The backoff instance used to schedule reconnection attempts.\n   */\n  private readonly _backoff: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _connectTimeout?: any;\n\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  private _connectTimeoutMs?: number;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _heartbeatTimeout?: any;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * Previous state of the connection\n   */\n  private _previousState: WSTransportState;\n\n  /**\n   * Whether we should attempt to fallback if we receive an applicable error\n   * when trying to connect to a signaling endpoint.\n   */\n  private _shouldFallback: boolean = false;\n\n  /**\n   * The currently connecting or open WebSocket.\n   */\n  private _socket?: WebSocket;\n\n  /**\n   * The time the active connection was opened.\n   */\n  private _timeOpened?: number;\n\n  /**\n   * The current uri index that the transport is connected to.\n   */\n  private _uriIndex: number = 0;\n\n  /**\n   * List of URI of the endpoints to connect to.\n   */\n  private readonly _uris: string[];\n\n  /**\n   * The constructor to use for WebSocket\n   */\n  private readonly _WebSocket: typeof WebSocket;\n\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  constructor(uris: string[], options: IWSTransportConstructorOptions = { }) {\n    super();\n\n    this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n\n    let initialDelay = 100;\n    if (uris && uris.length > 1) {\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n    }\n\n    const backoffConfig = {\n      factor: 2.0,\n      initialDelay,\n      maxDelay: typeof options.backoffMaxMs === 'number'\n        ? Math.max(options.backoffMaxMs, 3000)\n        : 20000,\n      randomisationFactor: 0.40,\n    };\n\n    this._log.info('Initializing transport backoff using config: ', backoffConfig);\n    this._backoff = Backoff.exponential(backoffConfig);\n\n    this._uris = uris;\n    this._WebSocket = options.WebSocket || WebSocket;\n\n    // Called when a backoff timer is started.\n    this._backoff.on('backoff', (_: any, delay: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._log.info(`Will attempt to reconnect WebSocket in ${delay}ms`);\n    });\n\n    // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n    this._backoff.on('ready', (attempt: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._connect(attempt + 1);\n    });\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  close(): void {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  }\n\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  open(): void {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket &&\n        (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n\n    this._connect();\n  }\n\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  send(message: string): boolean {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  private _close(): void {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  }\n\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  private _closeSocket(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose as any);\n    this._socket.removeEventListener('error', this._onSocketError as any);\n    this._socket.removeEventListener('message', this._onSocketMessage as any);\n    this._socket.removeEventListener('open', this._onSocketOpen as any);\n\n    if (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n\n    this._backoff.backoff();\n    delete this._socket;\n\n    this.emit('close');\n  }\n\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  private _connect(retryCount?: number): void {\n    if (retryCount) {\n      this._log.info(`Attempting to reconnect (retry #${retryCount})...`);\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n    let socket = null;\n    try {\n      socket = new this._WebSocket(this._uris[this._uriIndex]);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || `Could not connect to ${this._uris[this._uriIndex]}`,\n        twilioError: new SignalingErrors.ConnectionDisconnected(),\n      });\n      return;\n    }\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(() => {\n      this._log.info('WebSocket connection attempt timed out.');\n      this._moveUriIndex();\n      this._closeSocket();\n    }, this._connectTimeoutMs);\n\n    socket.addEventListener('close', this._onSocketClose as any);\n    socket.addEventListener('error', this._onSocketError as any);\n    socket.addEventListener('message', this._onSocketMessage as any);\n    socket.addEventListener('open', this._onSocketOpen as any);\n    this._socket = socket;\n  }\n\n  /**\n   * Move the uri index to the next index\n   * If the index is at the end, the index goes back to the first one.\n   */\n  private _moveUriIndex = (): void => {\n    this._uriIndex++;\n    if (this._uriIndex >= this._uris.length) {\n      this._uriIndex = 0;\n    }\n  }\n\n  /**\n   * Called in response to WebSocket#close event.\n   */\n  private _onSocketClose = (event: CloseEvent): void => {\n    this._log.info(`Received websocket close event code: ${event.code}. Reason: ${event.reason}`);\n    // 1006: Abnormal close. When the server is unreacheable\n    // 1015: TLS Handshake error\n    if (event.code === 1006 || event.code === 1015) {\n      this.emit('error', {\n        code: 31005,\n        message: event.reason ||\n          'Websocket connection to Twilio\\'s signaling servers were ' +\n          'unexpectedly ended. If this is happening consistently, there may ' +\n          'be an issue resolving the hostname provided. If a region or an ' +\n          'edge is being specified in Device setup, ensure it is valid.',\n        twilioError: new SignalingErrors.ConnectionError(),\n      });\n\n      const wasConnected = (\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        this.state === WSTransportState.Open ||\n\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        this._previousState === WSTransportState.Open\n      );\n\n      // Only fallback if this is not the first error\n      // and if we were not connected previously\n      if (this._shouldFallback || !wasConnected) {\n        this._moveUriIndex();\n      }\n\n      this._shouldFallback = true;\n    }\n    this._closeSocket();\n  }\n\n  /**\n   * Called in response to WebSocket#error event.\n   */\n  private _onSocketError = (err: Error): void => {\n    this._log.info(`WebSocket received error: ${err.message}`);\n    this.emit('error', {\n      code: 31000,\n      message: err.message || 'WSTransport socket error',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    });\n  }\n\n  /**\n   * Called in response to WebSocket#message event.\n   */\n  private _onSocketMessage = (message: IMessageEvent): void => {\n    // Clear heartbeat timeout on any incoming message, as they\n    // all indicate an active connection.\n    this._setHeartbeatTimeout();\n\n    // Filter and respond to heartbeats\n    if (this._socket && message.data === '\\n') {\n      this._socket.send('\\n');\n      return;\n    }\n\n    this.emit('message', message);\n  }\n\n  /**\n   * Called in response to WebSocket#open event.\n   */\n  private _onSocketOpen = (): void => {\n    this._log.info('WebSocket opened successfully.');\n    this._timeOpened = Date.now();\n    this._shouldFallback = false;\n    this._setState(WSTransportState.Open);\n    clearTimeout(this._connectTimeout);\n\n    this._setHeartbeatTimeout();\n    this.emit('open');\n  }\n\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  private _setHeartbeatTimeout(): void {\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(() => {\n      this._log.info(`No messages received in ${HEARTBEAT_TIMEOUT / 1000} seconds. Reconnecting...`);\n      this._shouldFallback = true;\n      this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  }\n\n  /**\n   * Set the current and previous state\n   */\n  private _setState(state: WSTransportState): void {\n    this._previousState = this.state;\n    this.state = state;\n  }\n\n  /**\n   * The uri the transport is currently connected to\n   */\n  get uri(): string {\n    return this._uris[this._uriIndex];\n  }\n}\n"]}