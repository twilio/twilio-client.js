{"version":3,"file":"wstransport.js","sourceRoot":"","sources":["../../lib/twilio/wstransport.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @module Tools\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport * as WebSocket from 'ws';\nimport Log, { LogLevel } from './tslog';\n\n// tslint:disable-next-line\nconst Backoff = require('backoff');\n\nconst CONNECT_SUCCESS_TIMEOUT = 10000;\nconst CONNECT_TIMEOUT = 5000;\nconst HEARTBEAT_TIMEOUT = 15000;\n\nexport interface IMessageEvent {\n  data: string;\n  target: WebSocket;\n  type: string;\n}\n\n/**\n * All possible states of WSTransport.\n */\nexport enum WSTransportState {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  Closed = 'closed',\n\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  Open = 'open',\n}\n\n/**\n * Options to be passed to the WSTransport constructor.\n */\nexport interface IWSTransportConstructorOptions {\n  /**\n   * Maximum time to wait before attempting to reconnect the signaling websocket.\n   * Default is 20000ms. Minimum is 3000ms.\n   */\n  backoffMaxMs?: number;\n\n  /**\n   * Minimum log level.\n   */\n  logLevel?: LogLevel;\n\n  /**\n   * A WebSocket factory to use instead of WebSocket.\n   */\n  WebSocket?: any;\n}\n\n/**\n * WebSocket Transport\n */\nexport default class WSTransport extends EventEmitter {\n  /**\n   * The current state of the WSTransport.\n   */\n  state: WSTransportState = WSTransportState.Closed;\n\n  /**\n   * The backoff instance used to schedule reconnection attempts.\n   */\n  private readonly _backoff: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _connectTimeout?: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _heartbeatTimeout?: any;\n\n  /**\n   * An instance of Log to use.\n   */\n  private readonly _log: Log;\n\n  /**\n   * The currently connecting or open WebSocket.\n   */\n  private _socket?: WebSocket;\n\n  /**\n   * The time the active connection was opened.\n   */\n  private _timeOpened?: number;\n\n  /**\n   * The URI of the endpoint being connected to.\n   */\n  private readonly _uri: string;\n\n  /**\n   * The constructor to use for WebSocket\n   */\n  private readonly _WebSocket: typeof WebSocket;\n\n  /**\n   * @constructor\n   * @param uri - The URI of the endpoint to connect to.\n   * @param [options] - Constructor options.\n   */\n  constructor(uri: string, options: IWSTransportConstructorOptions = { }) {\n    super();\n\n    this._backoff = Backoff.exponential({\n      factor: 2.0,\n      initialDelay: 100,\n      maxDelay: typeof options.backoffMaxMs === 'number'\n        ? Math.max(options.backoffMaxMs, 3000)\n        : 20000,\n      randomisationFactor: 0.40,\n    });\n\n    this._log = new Log(options.logLevel || LogLevel.Off);\n    this._uri = uri;\n    this._WebSocket = options.WebSocket || WebSocket;\n\n    // Called when a backoff timer is started.\n    this._backoff.on('backoff', (_: any, delay: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._log.info(`Will attempt to reconnect WebSocket in ${delay}ms`);\n    });\n\n    // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n    this._backoff.on('ready', (attempt: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._connect(attempt + 1);\n    });\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  close(): void {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  }\n\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  open(): void {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket &&\n        (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n\n    this._connect();\n  }\n\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  send(message: string): boolean {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  private _close(): void {\n    this.state = WSTransportState.Closed;\n    this._closeSocket();\n  }\n\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  private _closeSocket(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose as any);\n    this._socket.removeEventListener('error', this._onSocketError as any);\n    this._socket.removeEventListener('message', this._onSocketMessage as any);\n    this._socket.removeEventListener('open', this._onSocketOpen as any);\n\n    if (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n\n    this._backoff.backoff();\n    delete this._socket;\n\n    this.emit('close');\n  }\n\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  private _connect(retryCount?: number): void {\n    if (retryCount) {\n      this._log.info(`Attempting to reconnect (retry #${retryCount})...`);\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n\n    this._closeSocket();\n\n    this.state = WSTransportState.Connecting;\n    let socket = null;\n    try {\n      socket = new this._WebSocket(this._uri);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', { code: 31000, message: e.message || `Could not connect to ${this._uri}` });\n      return;\n    }\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(() => {\n      this._log.info('WebSocket connection attempt timed out.');\n      this._closeSocket();\n    }, CONNECT_TIMEOUT);\n\n    socket.addEventListener('close', this._onSocketClose as any);\n    socket.addEventListener('error', this._onSocketError as any);\n    socket.addEventListener('message', this._onSocketMessage as any);\n    socket.addEventListener('open', this._onSocketOpen as any);\n    this._socket = socket;\n  }\n\n  /**\n   * Called in response to WebSocket#close event.\n   */\n  private _onSocketClose = (): void => {\n    this._closeSocket();\n  }\n\n  /**\n   * Called in response to WebSocket#error event.\n   */\n  private _onSocketError = (err: Error): void => {\n    this._log.info(`WebSocket received error: ${err.message}`);\n    this.emit('error', { code: 31000, message: err.message || 'WSTransport socket error' });\n  }\n\n  /**\n   * Called in response to WebSocket#message event.\n   */\n  private _onSocketMessage = (message: IMessageEvent): void => {\n    // Clear heartbeat timeout on any incoming message, as they\n    // all indicate an active connection.\n    this._setHeartbeatTimeout();\n\n    // Filter and respond to heartbeats\n    if (this._socket && message.data === '\\n') {\n      this._socket.send('\\n');\n      return;\n    }\n\n    this.emit('message', message);\n  }\n\n  /**\n   * Called in response to WebSocket#open event.\n   */\n  private _onSocketOpen = (): void => {\n    this._log.info('WebSocket opened successfully.');\n    this._timeOpened = Date.now();\n    this.state = WSTransportState.Open;\n    clearTimeout(this._connectTimeout);\n\n    this._setHeartbeatTimeout();\n    this.emit('open');\n  }\n\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  private _setHeartbeatTimeout(): void {\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(() => {\n      this._log.info(`No messages received in ${HEARTBEAT_TIMEOUT / 1000} seconds. Reconnecting...`);\n      this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  }\n}\n"]}