{"version":3,"file":"mos.js","sourceRoot":"","sources":["../../../lib/twilio/rtc/mos.ts"],"names":[],"mappings":";;AAAA,IAAM,EAAE,GAAG,MAAM,CAAC,CAAC,wCAAwC;AAE3D;;;;;;;;;GASG;AACH,SAAgB,SAAS,CACvB,GAAQ,EACR,MAAW,EACX,YAAiB;IAEjB,IACE,OAAO,GAAG,KAAK,QAAQ;QACvB,OAAO,MAAM,KAAK,QAAQ;QAC1B,OAAO,YAAY,KAAK,QAAQ;QAChC,CAAC,mBAAmB,CAAC,GAAG,CAAC;QACzB,CAAC,mBAAmB,CAAC,MAAM,CAAC;QAC5B,CAAC,mBAAmB,CAAC,YAAY,CAAC,EAClC;QACA,OAAO,IAAI,CAAC;KACb;IAED,iCAAiC;IACjC,IAAM,gBAAgB,GAAW,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;IAEzD,wDAAwD;IACxD,IAAI,OAAO,GAAW,CAAC,CAAC;IACxB,QAAQ,IAAI,EAAE;QACZ,KAAK,gBAAgB,GAAG,GAAG;YACzB,OAAO,GAAG,EAAE,GAAG,CAAC,gBAAgB,GAAG,EAAE,CAAC,CAAC;YACvC,MAAM;QACR,KAAK,gBAAgB,GAAG,IAAI;YAC1B,OAAO,GAAG,EAAE,GAAG,CAAC,CAAC,gBAAgB,GAAG,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;YAC/C,MAAM;KACT;IAED,sDAAsD;IACtD,QAAQ,IAAI,EAAE;QACZ,KAAK,YAAY,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC;YAClC,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,YAAY,GAAG,GAAG,EAAE,IAAI,CAAC,CAAC;YACvD,MAAM;QACR;YACE,OAAO,GAAG,CAAC,CAAC;YACZ,MAAM;KACT;IAED,8BAA8B;IAC9B,IAAM,GAAG,GAAW,CAAC;QACnB,CAAC,KAAK,GAAG,OAAO,CAAC;QACjB,CAAC,QAAQ,GAAG,OAAO,CAAC;YACpB,CAAC,OAAO,GAAG,EAAE,CAAC;YACd,CAAC,GAAG,GAAG,OAAO,CAAC,CAAC;IAElB,OAAO,GAAG,CAAC;AACb,CAAC;AAhDD,8BAgDC;AAED;;;;GAIG;AACH,SAAgB,mBAAmB,CAAC,CAAM;IACxC,OAAO,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACrE,CAAC;AAFD,kDAEC;AAED,kBAAe;IACb,SAAS,WAAA;IACT,mBAAmB,qBAAA;CACpB,CAAC","sourcesContent":["const r0 = 94.768; // Constant used in computing \"rFactor\".\n\n/**\n * Calculate the mos score of a stats object\n * @param {number} rtt\n * @param {number} jitter\n * @param {number} fractionLost - The fraction of packets that have been lost.\n * Calculated by packetsLost / totalPackets\n * @return {number | null} mos - Calculated MOS, `1.0` through roughly `4.5`.\n * Returns `null` when any of the input parameters are not a `non-negative`\n * number.\n */\nexport function calculate(\n  rtt: any,\n  jitter: any,\n  fractionLost: any,\n): number | null {\n  if (\n    typeof rtt !== 'number' ||\n    typeof jitter !== 'number' ||\n    typeof fractionLost !== 'number' ||\n    !isNonNegativeNumber(rtt) ||\n    !isNonNegativeNumber(jitter) ||\n    !isNonNegativeNumber(fractionLost)\n  ) {\n    return null;\n  }\n\n  // Compute the effective latency.\n  const effectiveLatency: number = rtt + (jitter * 2) + 10;\n\n  // Compute the initial \"rFactor\" from effective latency.\n  let rFactor: number = 0;\n  switch (true) {\n    case effectiveLatency < 160:\n      rFactor = r0 - (effectiveLatency / 40);\n      break;\n    case effectiveLatency < 1000:\n      rFactor = r0 - ((effectiveLatency - 120) / 10);\n      break;\n  }\n\n  // Adjust \"rFactor\" with the fraction of packets lost.\n  switch (true) {\n    case fractionLost <= (rFactor / 2.5):\n      rFactor = Math.max(rFactor - fractionLost * 2.5, 6.52);\n      break;\n    default:\n      rFactor = 0;\n      break;\n  }\n\n  // Compute MOS from \"rFactor\".\n  const mos: number = 1 +\n    (0.035 * rFactor) +\n    (0.000007 * rFactor) *\n    (rFactor - 60) *\n    (100 - rFactor);\n\n  return mos;\n}\n\n/**\n * Returns true if and only if the parameter passed is a number, is not `NaN`,\n * is finite, and is greater than or equal to `0`.\n * @param n\n */\nexport function isNonNegativeNumber(n: any): boolean {\n  return typeof n === 'number' && !isNaN(n) && isFinite(n) && n >= 0;\n}\n\nexport default {\n  calculate,\n  isNonNegativeNumber,\n};\n"]}