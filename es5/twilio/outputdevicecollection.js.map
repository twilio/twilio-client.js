{"version":3,"file":"outputdevicecollection.js","sourceRoot":"","sources":["../../lib/twilio/outputdevicecollection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n */\nimport { SOUNDS_BASE_URL } from './constants';\nimport { InvalidArgumentError, InvalidStateError, NotSupportedError } from './errors';\nconst DEFAULT_TEST_SOUND_URL = `${SOUNDS_BASE_URL}/outgoing.mp3`;\n\n/**\n * A smart collection containing a Set of active output devices.\n * @publicapi\n */\nexport default class OutputDeviceCollection {\n  /**\n   * The currently active output devices.\n   */\n  private _activeDevices: Set<MediaDeviceInfo> = new Set();\n\n  /**\n   * @private\n   */\n  constructor(private _name: string,\n              private _availableDevices: Map<string, MediaDeviceInfo>,\n              private _beforeChange: (name: string, devices: string[]) => Promise<void>,\n              private _isSupported: boolean) { }\n\n  /**\n   * Delete a device from the collection. If no devices remain, the 'default'\n   * device will be added as the sole device. If no `default` device exists,\n   * the first available device will be used.\n   * @param device - The device to delete from the collection\n   * @returns whether the device was present before it was deleted\n   */\n  delete(device: MediaDeviceInfo): boolean {\n    const wasDeleted: boolean = !!(this._activeDevices.delete(device));\n\n    const defaultDevice: MediaDeviceInfo = this._availableDevices.get('default')\n      || Array.from(this._availableDevices.values())[0];\n\n    if (!this._activeDevices.size && defaultDevice) {\n      this._activeDevices.add(defaultDevice);\n    }\n\n    // Call _beforeChange so that the implementation can react when a device is\n    // removed or lost.\n    const deviceIds = Array.from(this._activeDevices.values()).map(deviceInfo => deviceInfo.deviceId);\n\n    this._beforeChange(this._name, deviceIds);\n    return !!wasDeleted;\n  }\n\n  /**\n   * Get the current set of devices.\n   */\n  get(): Set<MediaDeviceInfo> {\n    return this._activeDevices;\n  }\n\n  /**\n   * Replace the current set of devices with a new set of devices.\n   * @param deviceIdOrIds - An ID or array of IDs of devices to replace the existing devices with.\n   * @returns Rejects if this feature is not supported, any of the supplied IDs are not found,\n   * or no IDs are passed.\n   */\n  set(deviceIdOrIds: string | string[]): Promise<void> {\n    if (!this._isSupported) {\n      return Promise.reject(new NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    const deviceIds: string[] = Array.isArray(deviceIdOrIds) ? deviceIdOrIds : [deviceIdOrIds];\n\n    if (!deviceIds.length) {\n      return Promise.reject(new InvalidArgumentError('Must specify at least one device to set'));\n    }\n\n    const missingIds: string[] = [];\n    const devices: Array<MediaDeviceInfo | undefined> = deviceIds.map((id: string) => {\n      const device: MediaDeviceInfo | undefined = this._availableDevices.get(id);\n      if (!device) { missingIds.push(id); }\n      return device;\n    });\n\n    if (missingIds.length) {\n      return Promise.reject(new InvalidArgumentError(`Devices not found: ${missingIds.join(', ')}`));\n    }\n\n    return new Promise(resolve => {\n      resolve(this._beforeChange(this._name, deviceIds));\n    }).then(() => {\n      this._activeDevices.clear();\n      devices.forEach(this._activeDevices.add, this._activeDevices);\n    });\n  }\n\n  /**\n   * Test the devices by playing audio through them.\n   * @param [soundUrl] - An optional URL. If none is specified, we will\n   *   play a default test tone.\n   * @returns Resolves with the result of the underlying HTMLAudioElements' play() calls.\n   */\n  test(soundUrl: string = DEFAULT_TEST_SOUND_URL): Promise<any> {\n    if (!this._isSupported) {\n      return Promise.reject(new NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    if (!this._activeDevices.size) {\n      return Promise.reject(new InvalidStateError('No active output devices to test'));\n    }\n\n    return Promise.all(Array.from(this._activeDevices).map((device: MediaDeviceInfo) => {\n      let el: HTMLAudioElement;\n\n      // (rrowland) We need to wait for the oncanplay event because of a regression introduced\n      // in Chrome M72: https://bugs.chromium.org/p/chromium/issues/detail?id=930876\n      return new Promise((resolve: Function) => {\n        el = new Audio(soundUrl);\n        (el as any).oncanplay = resolve;\n      }).then(() => (el as any).setSinkId(device.deviceId).then(() => el.play()));\n    }));\n  }\n}\n"]}