{"version":3,"file":"asyncQueue.js","sourceRoot":"","sources":["../../lib/twilio/asyncQueue.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;GAIG;AACH,uCAAkC;AAElC;;GAEG;AACH;IAAA;QACE;;WAEG;QACK,gBAAW,GAA2B,EAAE,CAAC;IAmDnD,CAAC;IAjDC;;;;OAIG;IACH,4BAAO,GAAP,UAAQ,QAA4B;QAClC,IAAM,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;QAC7C,IAAM,QAAQ,GAAG,IAAI,kBAAQ,EAAE,CAAC;QAEhC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,QAAQ,UAAA,EAAE,QAAQ,UAAA,EAAE,CAAC,CAAC;QAE9C,IAAI,CAAC,UAAU,EAAE;YACf,IAAI,CAAC,aAAa,EAAE,CAAC;SACtB;QAED,OAAO,QAAQ,CAAC,OAAO,CAAC;IAC1B,CAAC;IAED;;;OAGG;IACW,kCAAa,GAA3B;;;;;;6BACS,IAAI,CAAC,WAAW,CAAC,MAAM;wBAEtB,KAAyB,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAA1C,QAAQ,cAAA,EAAE,QAAQ,cAAA,CAAyB;wBAG/C,MAAM,SAAA,CAAC;wBACP,KAAK,SAAA,CAAC;wBAEN,WAAW,SAAA,CAAC;;;;wBAEL,qBAAM,QAAQ,EAAE,EAAA;;wBAAzB,MAAM,GAAG,SAAgB,CAAC;wBAC1B,WAAW,GAAG,IAAI,CAAC;;;;wBAEnB,KAAK,GAAG,GAAC,CAAC;;;wBAGZ,kBAAkB;wBAClB,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;wBAEzB,IAAI,WAAW,EAAE;4BACf,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;yBAC1B;6BAAM;4BACL,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBACxB;;;;;;KAEJ;IACH,iBAAC;AAAD,CAAC,AAvDD,IAuDC;AAvDY,gCAAU","sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\nimport Deferred from './deferred';\n\n/**\n * Queue async operations and executes them synchronously.\n */\nexport class AsyncQueue {\n  /**\n   * The list of async operations in this queue\n   */\n  private _operations: AsyncQueue.Operation[] = [];\n\n  /**\n   * Adds the async operation to the queue\n   * @param callback An async callback that returns a promise\n   * @returns A promise that will get resolved or rejected after executing the callback\n   */\n  enqueue(callback: () => Promise<any>): Promise<any> {\n    const hasPending = !!this._operations.length;\n    const deferred = new Deferred();\n\n    this._operations.push({ deferred, callback });\n\n    if (!hasPending) {\n      this._processQueue();\n    }\n\n    return deferred.promise;\n  }\n\n  /**\n   * Start processing the queue. This executes the first item and removes it after.\n   * Then do the same for next items until the queue is emptied.\n   */\n  private async _processQueue() {\n    while (this._operations.length) {\n      // Grab first item, don't remove from array yet until it's resolved/rejected\n      const { deferred, callback } = this._operations[0];\n\n      // We want to capture the result/error first so we can remove the item from the queue later\n      let result;\n      let error;\n      // Sometimes result and error are empty. So let's use a separate flag to determine if the promise has resolved\n      let hasResolved;\n      try {\n        result = await callback();\n        hasResolved = true;\n      } catch (e) {\n        error = e;\n      }\n\n      // Remove the item\n      this._operations.shift();\n\n      if (hasResolved) {\n        deferred.resolve(result);\n      } else {\n        deferred.reject(error);\n      }\n    }\n  }\n}\n\nexport namespace AsyncQueue {\n  /**\n   * Represent an [[AsyncQueue]] operation\n   */\n  export interface Operation {\n    /**\n     * An async callback that returns a promise. This will get called once it reaches the queue.\n     */\n    callback: () => Promise<any>;\n\n    /**\n     * A deferred promise that gets resolved or rejected after executing the async callback\n     */\n    deferred: Deferred;\n  }\n}\n"]}